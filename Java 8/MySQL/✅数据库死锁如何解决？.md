# 典型回答

数据库死锁问题是指在多个并发事务中，彼此之间出现了相互等待的情况，导致所有事务都无法继续执行，称为死锁。

关于死锁的概念：<br />[✅什么是死锁，如何解决？](https://www.yuque.com/hollis666/fo22bm/mtdxsd?view=doc_embed)

数据库的死锁的发生通常由以下原因导致：

1. 资源竞争：多个事务试图同时访问相同的资源，如数据库表、行、页或锁。但是它们请求资源的顺序不同，导致互相等待。
2. 未释放资源：事务在使用完资源后未及时释放资源，导致其他事务无法获得所需的资源。这可能是由于程序中的错误或异常情况引起的。
3. 不同事务的执行速度不同：如果一个事务在获取资源后执行速度很慢，而其他事务需要等待该事务释放资源，那么可能会导致其他事务超时，从而发生死锁。
4. 操作的数据量过大：在持有锁的同时，又请求获取更多的锁，导致互相等待。


**如果发生了死锁，如何解决**：<br />1、大部分现代数据库管理系统在检测到死锁时会**自动干预**。它们通常选择回滚一个或多个事务来打破死锁。<br />2、除了自动干预外，很多 DBMS 也支持**手动强制回滚**某些事务来解决死锁。比如 navicat 解决死锁的办法：[https://www.cnblogs.com/xbdeng/p/16541111.html](https://www.cnblogs.com/xbdeng/p/16541111.html)<br />3、还有就是如果你什么都不做，MySQL 自己也可以解决死锁，一种是立刻解决，一种是延迟解决。

- 如果MySQL开启了死锁检测（`innodb_deadlock_detect = on` ），那么他会定时的检测死锁，在检测到死锁后，MySQL将自动选择并终止事务中的一个或多个事务来解决死锁。
- 如何设置事务等待锁的超时时间（`innodb_lock_wait_timeout`）。当一个事务的等待获取锁的时长超过这个阈值的时候，会对这个事务进行回滚，这样也能解决死锁。



**避免死锁**的方法有：<br />1、减少锁的数量：比如使用RC来代替RR来避免因为gap锁和next-key锁而带来的死锁情况。<br />2、减少锁的时长：加快事务的执行速度，降低执行时间，也能减少死锁发生的概率。<br />3、固定顺序访问数据：事务在访问同一张表时，应该以相同的顺序获取锁，这样可以避免死锁的发生。<br />4、减少操作的数据量：尽量减少事务操作的数据量，尽量减少事务的持有时间，这样可以降低死锁的发生几率。

[✅数据库死锁问题排查过程](https://www.yuque.com/hollis666/fo22bm/yywypm?view=doc_embed)
